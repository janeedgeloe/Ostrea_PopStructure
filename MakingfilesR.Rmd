---
title: "Making files for other programs"
author: "Katherine Silliman"
output: 
  github_document:
    toc: yes
---

# Load adegenet objects
```{r}
load("PCA/OL-c80-66-s67-m70x62-maf025-u.adegenet")
load("PCA/All5C-c80-66-s67-m70x62-mac4-u.adegenet")
load("PCA/All-c80-66-m70x62-mac4.adegenet")
g.indF
```
```{r}
All.g.indm70
```
```{r}
all.g.ind
```
# Make input for OutFLANK
```{r}
#Write file with allele counts per individual for OutFLANK
write.table(g.indF@tab, file = "Outlier/OL-66-m70x62-maf025.tab",sep = "\t",row.names = T,col.names = T,quote = F )
write.table(strata(g.indF)$Population, file = "Outlier/OL-66-m70x62-maf025.pop",sep = "\t",row.names = F,col.names = F,quote = F )
write.table(strata(g.indF)$Region, file = "Outlier/OL-66-m70x62-maf025.regs",sep = "\t",row.names = F,col.names = F,quote = F )
```

# Make Treemix file
```{r}
OL.gp <- genind2genpop(g.indF,pop=strata(g.indF)$Population)
write.table(OL.gp$tab, file="Treemix/OL-m70x62-maf025.gp",sep = "\t",row.names = T,col.names = T,quote = F )
system('python ../../Methods/Scripts/genpop2Treemix.py Treemix/OL-m70x62-maf025.gp Treemix/OL-m70x62-maf025.TM.txt')
system('gzip Treemix/OL-m70x62-maf025.TM.txt')
```
# Make an EEMS file
## OL- with OR

```{r}
suf <- "EEMS/OL-m70x62-maf025"
geno <- g.indF@tab
stopifnot(identical(g.indF@type, 'codom'))
# Get rid of non-biallelic loci
multi.loci <- names(which(g.indF@loc.n.all != 2))
multi.cols <- which(grepl(paste0("^", multi.loci, "\\.\\d+$", collapse = "|"), colnames(geno)))
if (length(multi.cols)) geno <- geno[, - multi.cols]
nloci <- dim(geno)[2] / 2
#Choose allele to be "derived" allele.
geno <- geno[, c(seq(1,ncol(geno),by = 2))]

dim(geno)
```
bed2diff functions
```{r}
bed2diffs_v1 <- function(Geno) {
  nIndiv <- nrow(Geno)
  nSites <- ncol(Geno)
  Diffs <- matrix(0, nIndiv, nIndiv)
  
  for (i in seq(nIndiv - 1)) {
    for (j in seq(i + 1, nIndiv)) {
      x <- Geno[i, ]
      y <- Geno[j, ]
      Diffs[i, j] <- mean((x - y)^2, na.rm = TRUE)
      Diffs[j, i] <- Diffs[i, j]
    }
  }
  Diffs
}
bed2diffs_v2 <- function(Geno) {
  nIndiv <- nrow(Geno)
  nSites <- ncol(Geno)
  Miss <- is.na(Geno)
  ## Impute NAs with the column means (= twice the allele frequencies)
  Mean <- matrix(colMeans(Geno, na.rm = TRUE), ## a row of means
                 nrow = nIndiv, ncol = nSites, byrow = TRUE) ## a matrix with nIndiv identical rows of means
  Mean[Miss == 0] <- 0 ## Set the means that correspond to observed genotypes to 0
  Geno[Miss == 1] <- 0 ## Set the missing genotypes to 0 (used to be NA) 
  Geno <- Geno + Mean
  ## Compute similarities
  Sim <- Geno %*% t(Geno) / nSites
  SelfSim <- diag(Sim) ## self-similarities
  vector1s <- rep(1, nIndiv) ## vector of 1s
  ## This chunk generates a `diffs` matrix
  Diffs <- SelfSim %*% t(vector1s) + vector1s %*% t(SelfSim) - 2 * Sim
  Diffs
}
```

```{r}
# 137 inds, 9,170 loci
#bed2diffs functions  
diffs.v1 <- bed2diffs_v1(geno)
diffs.v2 <- bed2diffs_v2(geno)
diffs.v1 <- round(diffs.v1, digits = 6)
diffs.v2 <- round(diffs.v2, digits = 6)
```
Check that the dissimilarity matrix has one positive eigenvalue and nIndiv-1 negative eigenvalues, as required by a full-rank Euclidean distance matrix.
```{r}
sort(round(eigen(diffs.v1)$values, digits = 2))
sort(round(eigen(diffs.v2)$values, digits = 2))
```
Make distance matrix
```{r}
## Get gps coordinates.
pop2gps <- read.table(file = "../Making_Files/OLPop2Int_Loc.txt", header=T)
names <- indNames(g.indF)
N = length(names)
gps_matrix = matrix(data = NA, nrow = N, ncol = 2)
for(i in 1:nrow(pop2gps)){
    popmatch <- grep(pop2gps[i,1],names,value=FALSE)
    for(j in popmatch){
        gps_matrix[j,2] <- pop2gps$Latitude[i]
        gps_matrix[j,1] <- pop2gps$Longitude[i]
    }
}
```
Write file for v1
```{r}
write.table(diffs.v1, paste(suf,".v1.diffs",sep=""), 
            col.names = FALSE, row.names = FALSE, quote = FALSE)
write.table(gps_matrix, paste(suf,".v1.coord",sep=""),col.names = FALSE, row.names = FALSE,quote = FALSE)
```

```{r}
gind.xOR <- g.indF[!(indNames(g.indF) %in% c("OR1_1","OR1_7","OR1_11","OR1_12","OR1_1B_6","OR1_2","OR1_3","OR1_4","OR1_5","OR1_6","OR1_7w_6")),drop=TRUE]

suf <- "EEMS/OL-m70x62-maf025-xOR1"
geno <- gind.xOR@tab
stopifnot(identical(gind.xOR@type, 'codom'))
# Get rid of non-biallelic loci
multi.loci <- names(which(gind.xOR@loc.n.all != 2))
multi.cols <- which(grepl(paste0("^", multi.loci, "\\.\\d+$", collapse = "|"), colnames(geno)))
if (length(multi.cols)) geno <- geno[, - multi.cols]
nloci <- dim(geno)[2] / 2
#Choose allele to be "derived" allele.
geno <- geno[, c(seq(1,ncol(geno),by = 2))]

dim(geno)
```

```{r}
# 130 inds, 9,170 loci
#bed2diffs functions  
diffs.v1 <- bed2diffs_v1(geno)
diffs.v2 <- bed2diffs_v2(geno)
diffs.v1 <- round(diffs.v1, digits = 6)
diffs.v2 <- round(diffs.v2, digits = 6)
```
Check that the dissimilarity matrix has one positive eigenvalue and nIndiv-1 negative eigenvalues, as required by a full-rank Euclidean distance matrix.
```{r}
sort(round(eigen(diffs.v1)$values, digits = 2))
sort(round(eigen(diffs.v2)$values, digits = 2))
```
Make distance matrix
```{r}
## Get gps coordinates.
pop2gps <- read.table(file = "../Making_Files/OLPop2Int_Loc.txt", header=T)
names <- indNames(gind.xOR)
N = length(names)
gps_matrix = matrix(data = NA, nrow = N, ncol = 2)
for(i in 1:nrow(pop2gps)){
    popmatch <- grep(pop2gps[i,1],names,value=FALSE)
    for(j in popmatch){
        gps_matrix[j,2] <- pop2gps$Latitude[i]
        gps_matrix[j,1] <- pop2gps$Longitude[i]
    }
}
```
Write file for v1
```{r}
write.table(diffs.v1, paste(suf,".v1.diffs",sep=""), 
            col.names = FALSE, row.names = FALSE, quote = FALSE)
write.table(gps_matrix, paste(suf,".v1.coord",sep=""),col.names = FALSE, row.names = FALSE,quote = FALSE)
```
## Plot EEMS
After running, plot EEMS output:
```{r}
library(rEEMSplots) #Get from EEMS github
library(rgdal)
library(rworldmap)
library(rworldxtra)
```
```{r}
eems.plots(mcmcpath = "EEMS/OL-c80-m70x62-maf025-xOR1_results/OL-m70x62maf025-xOR1-nD400-ch1", plotpath = "EEMS/OL-c80-m70x62-maf025-xOR1_results/OL-m70x62maf025-xOR1-nD400-ch1-plots",longlat = T,add.grid=F,add.outline = T,add.demes = T,projection.in = "+proj=longlat +datum=WGS84",projection.out = "+proj=merc +datum=WGS84",add.map = T,add.abline = T, add.r.squared = T)
```
